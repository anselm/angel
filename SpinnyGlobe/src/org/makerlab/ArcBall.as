package org.makerlab {		import flash.geom.Matrix;	import flash.events.*;	import flash.display.Sprite;	import org.papervision3d.core.math.*;	/**	 * arcball manipulator with specialization for handling flash events	 * may have a tiny bit of glue to deal with longitude and latitude	 * 	 * anselm notes aug 24 2007:	 * see http://processing.org arcball demo      * at http://www.chronotext.org/bits/030	 * note that Matrix3D has some of this built-in     * TODO : merge with Matrix3D 	 */	public class ArcBall extends Manipulator {		// state		public var xCenter:Number 		= 0;		public var yCenter:Number 		= 0;		public var surface:Number;  		public var is_down:Boolean 		= false;		public var vdown:Number3D 		= new Number3D(0,0,1);		public var vdrag:Number3D 		= new Number3D(0,0,1);		public var qnow:Quaternion 		= new Quaternion();		public var qdown:Quaternion 	= new Quaternion();		public var qdrag:Quaternion 	= new Quaternion();		public var transform:Matrix3D	= new Matrix3D();		// debug		public var mx:Number 			= 0; 	// incoming mouse values		public var my:Number 			= 0;		public var mag:Number 			= 0; 	// magnitude of mouse		public var angleX:Number 		= 0;		public var angleY:Number 		= 0;		// CONSTRUCTOR		public function ArcBall(_surface:Number = 1000, 								_xWidth:Number = 300,								_yWidth:Number = 300								) {			this.xCenter = _xWidth/2;			this.yCenter = _yWidth/2;			this.surface = _surface;			transform = qnow.to_mat();		}		// mouse_to_sphere		// figure out where the mouse is on the surface of the sphere		// as a vector in 3 dimensions.		// always generate a vector of length 1		// TODO: refine and nail down the diameter better		public function mouse_to_sphere(			target:Number3D, x:Number = 0, y:Number = 0):void {			mx 			= x - xCenter;			my 			= yCenter - y;				target.x	= ( mx / surface ) / Math.pow(2,zoom);			target.y 	= ( my / surface ) / Math.pow(2,zoom);			mag 		= target.x * target.x + target.y * target.y;			if (mag <= 1) {				target.z = Math.sqrt(1 - mag);				target.normalize();			} else {				target.z = 1;			}		}		/*		 * get product of arcballs work		 */		public override function get_transform():Matrix3D {			return transform;		}		// event_mouse_up		public override function event_mouse_up(e:MouseEvent):void {			// release the latch on the down state			is_down = false;		}		// event_mouse_down		public override function event_mouse_down(e:MouseEvent):void {			if( e.relatedObject != null ) return;			// already latched the down state?			if(is_down == true) {				//return;			}			is_down = true;			// get a vector expressing where mouse was pressed			mouse_to_sphere(vdown, e.stageX, e.stageY);			// hold onto the previous orientation of the sphere			qdown.set(qnow);		}		// event_mouse_move		public override function event_mouse_move(e:MouseEvent):void {			if( e.relatedObject != null ) return;			// down state latched?			if(is_down == false || e.buttonDown == false) {				return;			}			// get a vector expressing where the mouse is now			mouse_to_sphere(vdrag, e.stageX, e.stageY);			// compute transit between mouse down and mouse current			qdrag.set2(				Number3D.dot(vdown, vdrag),				Number3D.cross(vdown, vdrag)				);			// add in the original orientation to get the total sum 			qnow.mul(qdrag,qdown); 			// turn this into a convenient transform for euler			transform = qnow.to_mat();		}	}}