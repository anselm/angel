package org.makerlab {	import flash.geom.Matrix;	import flash.events.*;	import flash.display.Sprite;	import org.papervision3d.core.math.*;	/**	 * vanilla rotation utility	 */	public class Rotater extends Manipulator {		// state		public var xCenter:Number 		= 0;		public var yCenter:Number 		= 0;		public var surface:Number		= 0;		public var is_down:Boolean 		= false;		public var baseline:Matrix3D	= Matrix3D.IDENTITY;		public var transform:Matrix3D	= Matrix3D.IDENTITY;		public var dx:Number			= 0;	// down mouse value		public var dy:Number			= 0;		public var mx:Number 			= 0; 	// incoming mouse values		public var my:Number 			= 0;		public var cx:Number 			= 0; 	// current skew		public var cy:Number 			= 0;		public var lx:Number 			= 0; 	// current skew		public var ly:Number 			= 0;				public override function reset():void {			is_down = false;			dx = 0;			dy = 0;			mx = 0;			my = 0;			cx = 0;			cy = 0;			lx = 0;			ly = 0;			zoom = 0;			baseline = Matrix3D.IDENTITY;			transform = Matrix3D.IDENTITY;			// hack - center over portland - move(350,150);		}		// CONSTRUCTOR		public function Rotater(_surface:Number = 1000, 								_xWidth:Number = 300,								_yWidth:Number = 300								) {			this.xCenter = _xWidth/2;			this.yCenter = _yWidth/2;			this.surface = _surface;			reset();		}				public override function get_transform():Matrix3D {			return transform;		}		public override function event_set_focus(_zoom:Number,latitude:Number,longitude:Number):void {			reset();			this.zoom = _zoom;			//latitude = Math.PI * latitude / 180;			//longitude = Math.PI * longitude / 180;			//baseline = Matrix3D.IDENTITY;			//baseline.calculateMultiply(transform,Matrix3D.rotationY(longitude));			//baseline.calculateMultiply(transform,Matrix3D.rotationX(latitude));			var x:Number = - surface * longitude / 180;			var y:Number = surface * latitude / 180;			move(x,y);		}		public override function event_mouse_up(e:MouseEvent):void {			is_down = false;			cx = lx;			cy = ly;		}		public override function event_mouse_down(e:MouseEvent):void {			if( e.relatedObject != null ) return;			is_down = true;			dx = e.stageX - xCenter;			dy = e.stageY - yCenter;		}		public override function event_mouse_move(e:MouseEvent):void {			if( e.relatedObject != null ) return;			if(is_down == false || e.buttonDown == false) {				is_down = false;				cx = lx;				cy = ly;				return;			}			// get current position; centered			mx = e.stageX - xCenter;			my = e.stageY - yCenter;			// get delta between live position and previous down position			mx = mx - dx;			my = my - dy;			// scale it down by zoom			mx = mx / Math.pow( 2, zoom );			my = my / Math.pow( 2, zoom );						// apply			move(mx,my);		}		public override function event_move(x:Number=0,y:Number=0):void {			move(x,y);			cx = lx;			cy = ly;		}		public function move(x:Number=0,y:Number=0):void {			// get new absolute values based on delta + current position			lx = cx + x;			ly = cy + y;			// constrain y axis freedom by say 45 degrees			if( ly > surface/3 ) ly = surface/3;			if( ly < -surface/3 ) ly = -surface/3;			transform = Matrix3D.IDENTITY;			transform.calculateMultiply( transform, Matrix3D.rotationY( -lx/surface * 3.1459 ) ),			transform.calculateMultiply( transform, Matrix3D.rotationX( ly/surface * 3.1459 ) );		}	}}